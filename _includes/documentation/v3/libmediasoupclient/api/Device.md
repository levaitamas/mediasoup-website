## Device
{: #Device}

<section markdown="1">

A device represents an endpoint that connects to a mediasoup [Router](/documentation/v3/mediasoup/api/#Router) to send and/or receive media.

<div markdown="1" class="note">
This is the entry point for C++ client side applications.
</div>

</section>


### Dictionaries
{: #Device-dictionaries}

<section markdown="1">

#### PeerConnection::Options
{: #PeerConnectionOptions .code}

<div markdown="1" class="table-wrapper L3">

Field           | Type    | Description   | Required | Default
--------------- | ------- | ------------- | -------- | ---------
`config`        | webrtc::PeerConnectionInterface::RTCConfiguration | PeerConnection configuration. | No |
`factory`       | webrtc::PeerConnectionFactoryInterface\* | PeerConnection factory. | No |

</div>

</section>


### Constructor
{: #Device-constructor}

<section markdown="1">

#### new Device()
{: #device-new-Device .code}

Creates a new device.

```c++
auto* device = new mediasoupclient::Device();
```

</section>


### Methods
{: #Device-methods}

<section markdown="1">

#### device.GetRtpCapabilities()
{: #device-GetRtpCapabilities .code}

The device RTP capabilities, generated by combining both the underlying WebRTC capabilities and the router RTP capabilities (see the [Load()](#device-Load) method).

> `@async` blocks current thread
>
> `@returns` const nlohmann::json& [RtpCapabilities](/documentation/v3/mediasoup/rtp-parameters-and-capabilities/#RtpCapabilities)
>
> `@throws` mediasoupclient::Exception, if device not loaded

<div markdown="1" class="note">
These RTP capabilities must be given to the mediasoup router in order to consume a remote stream. Check the [Communication Between Client and Server](/documentation/v3/communication-between-client-and-server/) section for more details.
</div>

#### device.IsLoaded()
{: #device-IsLoaded .code}

Whether the device has been loaded (see the [Load()](#device-Load) method).

> `@returns` bool


#### device.Load(routerRtpCapabilities, peerConnectionOptions = nullptr)
{: #device-Load .code}

Loads the device with the RTP capabilities of the mediasoup router. This is how the device knows about the allowed media codecs and other settings.

<div markdown="1" class="table-wrapper L3">

Argument      | Type    | Description | Required | Default 
------------- | ------- | ----------- | -------- | ----------
`routerRtpCapabilities` | const nlohmann::json& [RtpCapabilities](/documentation/v3/mediasoup/rtp-parameters-and-capabilities/#RtpCapabilities) | The mediasoup router RTP capabilities. | Yes |
`peerConnectionOptions` | [PeerConnection::Options\*](#PeerConnectionOptions) | PeerConnection options. | No   |

</div>

> `@throws` mediasoupclient::Exception, if device already loaded

<div markdown="1" class="note">
* The router RTP capabilities are exposed via the [router.rtpCapabilities](/documentation/v3/mediasoup/api/#router-rtpCapabilities) getter. Check the [Communication Between Client and Server](/documentation/v3/communication-between-client-and-server/) section for more details.

* See also how to [filter those server-side capabilities](/documentation/v3/tricks/#rtp-capabilities-filtering) before applying them to the libmediasoupclient device.
</div>

```c++
device.Load(routerRtpCapabilities);
// Now the device is ready.
```

#### device.CanProduce(kind)
{: #device-CanProduce .code}

Whether the device can produce media of the given kind. This depends on the media codecs enabled in the mediasoup router and the media capabilities of libwebrtc.

<div markdown="1" class="table-wrapper L3">

Argument  | Type    | Description | Required | Default 
--------- | ------- | ----------- | -------- | ----------
`kind`    | const std::string&  | "audio" or "video". | Yes |

</div>

> `@returns` bool
> 
> `@throws` mediasoupclient::Exception, if device not loaded
> 
> `@throws` mediasoupclient::Exception, if invalid kind

```c++
if (device.CanProduce("video"))
{
  // Produce video.
}
```

#### device.CreateSendTransport(listener, id, iceParameters, iceCandidates, dtlsParameters, peerConnectionOptions = nullptr, appData = {})
{: #device-CreateSendTransport .code}

Creates a new WebRTC transport to **send** media. The transport must be previously created in the mediasoup router via [router.createWebRtcTransport()](/documentation/v3/mediasoup/api/#router-createWebRtcTransport).

<div markdown="1" class="table-wrapper L3">

Argument         | Type    | Description   | Required | Default
---------------- | ------- | ------------- | -------- | ---------
`listener`       | [SendTransport::Listener](#SendTransportListener)  | The identifier of the server side transport. | Yes    |
`id`             | const std::string&  | The identifier of the server side transport. | Yes    |
`iceParameters`  | const nlohmann::json& [IceParameters](/documentation/v3/mediasoup/api/#WebRtcTransportIceParameters) | ICE parameters of the server side transport. | Yes   |
`iceCandidates`  | const nlohmann::json& Array&lt;[IceCandidate](/documentation/v3/mediasoup/api/#WebRtcTransportIceCandidate)&gt; | ICE candidates of the server side transport. | Yes   |
`dtlsParameters` | const nlohmann::json& [DtlsParameters](/documentation/v3/mediasoup/api/#WebRtcTransportDtlsParameters) | DTLS parameters of the server side transport. | Yes   |
`peerConnectionOptions` | [PeerConnection::Options\*](#PeerConnectionOptions) | PeerConnection options. | No   |
`appData`       | nlohmann::json  | Custom application data. | No | `{ }`

</div>

> `@returns` [SendTransport\*](#SendTransport)

```cpp
auto* sendTransportListener = new MySendTransportListener();

// This will block the current thread until completion.
auto* sendTransport = device.CreateSendTransport(
  sendTransportListener,
  id,
  iceParameters,
  iceCandidates,
  dtlsParameters);
```

#### device.CreateRecvTransport(listener, id, iceParameters, iceCandidates, dtlsParameters, peerConnectionOptions = nullptr, appData = {})
{: #device-CreateRecvTransport .code}

Creates a new WebRTC transport to **receive** media. The transport must be previously created in the mediasoup router via [router.createWebRtcTransport()](/documentation/v3/mediasoup/api/#router-createWebRtcTransport).

<div markdown="1" class="table-wrapper L3">

Argument         | Type    | Description   | Required | Default
---------------- | ------- | ------------- | -------- | ---------
`listener`       | [RecvTransport::Listener](#SendTransportListener)  | The identifier of the server side transport. | Yes    |
`id`             | const std::string&  | The identifier of the server side transport. | Yes    |
`iceParameters`  | const nlohmann::json& [IceParameters](/documentation/v3/mediasoup/api/#WebRtcTransportIceParameters) | ICE parameters of the server side transport. | Yes   |
`iceCandidates`  | const nlohmann::json& Array&lt;[IceCandidate](/documentation/v3/mediasoup/api/#WebRtcTransportIceCandidate)&gt; | ICE candidates of the server side transport. | Yes   |
`dtlsParameters` | const nlohmann::json& [DtlsParameters](/documentation/v3/mediasoup/api/#WebRtcTransportDtlsParameters) | DTLS parameters of the server side transport. | Yes   |
`peerConnectionOptions` | [PeerConnection::Options](#PeerConnectionOptions) | PeerConnection options. | No   |
`appData`       | nlohmann::json  | Custom application data. | No | `{ }`

</div>

>
> `@returns` [RecvTransport\*](#RecvTransport)

```c++
auto* recvTransportListener = new MyRecvTransportListener();

// This will block the current thread until completion.
auto* recvTransport = device.CreateRecvTransport(
  recvTransportListener,
  id,
  iceParameters,
  iceCandidates,
  dtlsParameters);
```

</section>
